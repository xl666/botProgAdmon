version: "3.1"

intents:
  - greet
  - goodbye
  - ejemplo
  - bot_challenge
  - temario
  - if_bloque
  - hash_bang
  - if_linea
  - encadenamiento
  - codigos_retorno
  - for
  - while
  - redireccion_flujo
  - variables
  - bloques
  - quoting
  - comandos_testing
  - funciones
  - recorrer_dirs
  - funciones_rec
  - globbing
  - expansion_comando
  - parametros
  - parametros_especiales
  - expansion_variables
  - getopts

responses:
  utter_greet:
  - text: "Hola qué tal"
  - text: "Hola"
  - text: "Buen día"
  - text: "Buenas"


  utter_goodbye:
  - text: "Bye"
  - text: "Adios"
  - text: "Nos vemos"
  - text: "Cuídate"
  - text: "Hasta la próxima"
  - text: "Ciao"

  utter_iamabot:
  - text: "Soy un bot, pero también tengo sentimientos"
  - text: "No soy humano, soy un bot"

  utter_sin_ejemplos:
  - text: "No tengo ejemplos para este tema, pide a tu maestro que agregue"
       
  utter_if_bloque_ayuda:
  - text: >
      - Recuerda que se puede poner cualquier comando en la condición,<br/>
        lo que importa es el código de retorno del comando

  utter_if_bloque_codigo:
  - text: "code:bash:bash/if_bloque.sh"

  utter_if_linea_ayuda:
  - text: >
      - Técnicamente no es un if, más bien una forma de encadenamiento<br />
      - El comando_condicion es cualquier comando, se evalúa código de retorno<br />
      - Si quieres saber más consulta el tema de encadenamiento

  utter_if_linea_codigo:
  - text: "code:bash:bash/if_linea.sh"    

  utter_hash_bang_ayuda:
  - text: >
      - Este comentario debe ir en la primera línea del script<br />
      - No debe haber espacios antes de ponerlo<br />
      - Le indica al sistema el intérprete que se desea usar<br />
      - Sirve para cualquier lenguaje interpretado, no sólo bash

  utter_hash_bang_codigo:
  - text: "code:bash:bash/hash_bang.sh"

  utter_encadenamiento_ayuda:
  - text: >
      - Sirve para ejecutar varios comandos seguidos<br />
      - Con ; siempre se ejecutan todos<br />
      - con && y || se ejecutan de acuerdo a valor de verdad

  utter_encadenamiento_complemento:
  - text: "Si quieres saber más revisa el tema de códigos de retorno"

  utter_encadenamiento_codigo:
  - text: "code:bash:bash/encadenamiento.sh"

  utter_encadenamiento_ejemplo_codigo:
  - text: "code:bash:bash/encadenamiento_ejemplo.sh"
    
  utter_codigos_retorno_ayuda:
  - text: >
      - Al terminar, todos los procesos le regresan un número al SO<br/>
      - Básicamente 0 es verdadero y cualquier otro número es falso

  utter_codigos_retorno_codigo:
  - text: "code:bash:bash/codigos_retorno.sh"

  utter_for_ayuda:
  - text: >
      - Se comporta como un for each (como el de python)<br />
      - Cuidado, se itera sobre una cadena<br />
      - Cada elemento en la cadena es separado por algún separador<br />
      - Por ejemplo, los espacios y saltos de línea son separadores<br />
      - Los caracteres separadores están definidos en la variable IFS<br />
      - Si editas IFS puedes cambiar el comportamiento de for     

  utter_for_codigo:
  - text: "code:bash:bash/for.sh"

  utter_for_ejemplo_codigo:
  - text: "code:bash:bash/for_ejemplo.sh"

  utter_while_ayuda:
  - text: >
      - Básicamente igual que en cualquier lenguaje<br />
      - En la condición lo que importa es el código de retorno del comando

  utter_while_codigo:
  - text: "code:bash:bash/while.sh"

  utter_while_ejemplo_codigo:
  - text: "code:bash:bash/while_ejemplo.sh"

  utter_redireccion_flujo_ayuda:
  - text: >
      - > Redirige salida estándar<br />
      - >> Redirige salida agregando al final<br />
      - < Redirige entrada<br />
      - 2> Redirige salida de error<br />
      - 2>> Redirige salida de error agregando al final<br />
      - &> Redirige salida y salida de error<br />
      - &>> Redirige salida y salida de error al final<br />
      - | Conecta salida y entrada de dos comandos<br />
        
  utter_redireccion_flujo_ejemplo_codigo:
  - text: "code:bash:bash/redireccion_ejemplo.sh"            
  utter_variables_ayuda:
  - text: >
      - No puedes dejar espacios en la declaración<br />
      - En bash no hay tipos de datos<br />
      - Todas las variables son cadenas<br />
      - Si una variable no existe su valor es cadena vacía<br />
      - Para recuperar el valor de una variable anteponer $<br />
      - CUIDADO la doble comilla no es para crear cadenas<br />
      - Para más información revisa el tema de quoting

  utter_variables_codigo:
  - text: "code:bash:bash/variables.sh"      

  utter_bloques_ayuda:
  - text: >
      - Sirven para hacer más de una cosa, agrupando comandos<br />
      - Hay contextos donde se espera sólo un comando pero se quieren varios<br />
      - Dentro del bloque los comandos van encadenados<br />
      - Hay que tener mucho cuidado con los espacios y los ;

  utter_bloques_codigo:
  - text: "code:bash:bash/bloques.sh"

  utter_bloques_ejemplo_codigo:
  - text: "code:bash:bash/bloques_ejemplo.sh"    

  utter_quoting_ayuda:
  - text: >
      - Se refiere a poner cosas entre comillas<br />
      - Las comillas pueden ser dobles o simples<br />
      - Es una forma de lidiar con los espacios<br/> 
      - Para bash los espacios pueden significar parámetros
      - Lo que esté entre comillas, aunque tenga espacios,<br />
        se considera como una sola cosa<br/>
      - La comilla doble expande valores<br/>
      - La comilla simple no expande valores<br/>
      - Siempre pon tus variables y parámetros entre doble comilla

  utter_quoting_ejemplo_codigo:
  - text: "code:bash:bash/quoting_ejemplo.sh"

  utter_comandos_testing_ayuda1:
  - text: >
      - Son comandos para hacer evaluaciones booleanas<br />
      - Al igual que otros comandos regresan un código de retorno<br />
      - NO son parte sintáctica de un if o un while<br />
      - Son 3 comandos de este tipo: test, [], [[]]<br />
      - test y [] son el mismo comando<br />
      - [[]] hace lo mismo que test pero tiene más opciones

  utter_comandos_testing_codigo:
  - text: "code:bash:bash/comandos_testing.sh"

  utter_comandos_testing_ejemplo_codigo:
  - text: "code:bash:bash/comandos_testing_ejemplo.sh"    

  utter_funciones_ayuda:
  - text: >
      - Sirven para agrupar funcionalidad y descomponer problemas<br />
      - Los parámetros que reciben son posicionales, como en un script<br />
      - Si quieres regresar un valor usa echo (trata de que sea uno)<br />
      - Con return se puede regresar un código de retorno<br />
      - Las funciones se invocan como cualquier comando<br />
      - Siempre que declares usa local para no definir en ámbito global
  
  utter_funciones_codigo:
  - text: "code:bash:bash/funciones.sh"

  utter_funciones_ejemplo_codigo:
  - text: "code:bash:bash/funciones_ejemplo.sh"        

  utter_recorrer_dirs_ayuda:
  - text: >
      - NUNCA uses ls para recorrer lo archivos de un directorio<br />
      - ls no funciona bien si hay espacios en los nombres de archivos<br />
      - Para este caso se debe usar globbing<br />
      - Es importante que el globbing quede fuera de comillas dobles<br />
      - Si quieres saber más revisa el tema de globbing<br />

  utter_recorrer_dirs_codigo:
  - text: "code:bash:bash/recorrer_dirs.sh"

  utter_funciones_rec_ayuda:
  - text: >
      - Son funciones que se mandan a llamar a si mismas<br />
      - Muy útiles para hacer recorridos recursivos de directorios<br />
      - Para usarlas hay que establecer casos base y recursivos<br />
      - Para procesar directorios recursivamente:<ol>
      <li>Define una función no recursiva para procesar un directorio</li>
      <li>Define una función recursiva que llama a la no recursiva<br/>
      y luego busca subdirectorios, llamando recursivamente la función</li></ol>

  utter_funciones_rec_codigo:
  - text: "code:bash:bash/funciones_rec.sh"

  utter_funciones_rec_ejemplo_codigo:
  - text: "code:bash:bash/funciones_rec_ejemplo.sh"          

  utter_globbing_ayuda1:
  - text: >
      - Sirve para sustituir rutas (y sólo rutas)<br />
      - Se expresa mediante un patrón que se expande a una o varias rutas<br />
      - Es de mucha utilidad para recorrer directorios<br />
      - También es de utilidad con comandos que reciben muchas rutas<br />
      - Bash expande los patrones antes de ejecutar el comando      

  utter_globbing_ayuda2:
  - text: >
      - * Hace match con cualquier cadena de longitud 0 o más<br />
      - ? Hace match con un solo carácter<br />
      - [caracteres] Hace match con uno de los caracteres<br />
      - \{\} Para especificar varios glob patterns separados por coma<br />
      - [[:clase:]] hace match con un carácter de una clase:<ul>
      <li>digit, word, space, alnum, alpha, lower, upper, cntrl</li></ul>

  utter_globbing_ejemplo_codigo:      
  - text: "code:bash:bash/globbing_ejemplo.sh"          

  utter_expansion_comando_codigo:      
  - text: "code:bash:bash/expansion_comando.sh"

  utter_expansion_comando_ejemplo_codigo:      
  - text: "code:bash:bash/expansion_comando_ejemplo.sh"              
    
  utter_expansion_comando_ayuda:
  - text: >
      - Sirven para convertir a cadena la salida de un comando<br />
      - Una vez que se tiene la cadena se puede usar en otro comando<br />
      - O se puede asignar a una variable<br />
      - Otro uso común es en un for<br />
      - Básicamente la salida del comando se expande a una cadena

  utter_parametros_ayuda:
  - text: >
      - Sirven para recibir entradas de usuario<br />
      - Los parámetros son variables especiales en tu script<br />
      - Son posicionales y constantes (no se puede cambiar su valor)<br />
      - En tu script tienes acceso a ellos mediante variables $1, $2, etc.<br />
      - Existe una variable especial $0 que contiene la ruta del script<br />
      - La ruta es relativa o absoluta de acuerdo a cómo se ejecutó el script<br />

  utter_parametros_ejemplo_codigo:      
  - text: "code:bash:bash/parametros_ejemplo.sh"                
  
  utter_parametros_especiales_ayuda:
  - text: >
      - * NO usarlo, expande a una cadena con todos los parámetros<br />
      - @ expando los parámetros como una lista de argumentos<br />
      - # número de parámetros pasados<br />
      - ? código de retorno del comando anterior<br />
      - - banderas de opciones que usa el shell<br />
      - $ PID del shell actual<br />
      - ! PID del último proceso ejecutado en segundo plano<br />
      - _ último argumento del comando anterior
      
  utter_parametros_especiales_ejemplo_codigo:      
  - text: "code:bash:bash/parametros_especiales_ejemplo.sh"                

  utter_expansion_variables_ayuda1:
  - text: >
      - Al expandir una variable se pueden hacer preprocesamientos<br />
      - La sintaxis general es ${variable}<br />
      - ${variable} es equivalente a $variable<br />
      - Sirve también para resolver casos ambiguos de expansiones<br />
      - Dicha sintaxis se acompaña de varios operadores especiales<br />
      - Los operadores especiales usan los mismos patrones que el globbing
      
  utter_expansion_variables_ayuda2:
  - text: >
      - ${var#patron} remueve cadena más corta desde la izquierda<br />
      - ${var##patron} remueve cadena más larga desde la izquierda<br />
      - ${var%patron} remueve cadena más corta desde la derecha<br />
      - ${var%%patron} remueve cadena más larga desde la derecha<br />
      - ${var/patron/remplazo} remplaza la primera cadena que hace match<br />
      - ${var//patron/remplazo} remplaza todas las cadenas que hacen match<br />
      - ${var/#patron/remplazo} remplaza primera cadena por la izquierda<br />
      - ${var/%patron/remplazo} remplaza primera cadena por la derecha<br />
      - ${#var} expande a la longitud del valor en bytes<br />
      - ${var:inicio[:longitud]} para hacer rebanadas<br />
      - ${var[^|^^|,|,,][patron]} a mayúsculas o minúsculas parte o todo

  utter_expansion_variables_ejemplo_codigo:      
  - text: "code:bash:bash/expansion_variables_ejemplo.sh"

  utter_getopts_ayuda:
  - text: >
      - Para integrar parámetros modificadores (keyword)<br />
      - Los modificadores no son posicionales<br />
      - getopts es un built-in de bash, sigue POSIX<br />
      - getopts está limitado a modificadores de una sola letra<br />
      - Los modificadores deben ir antes de parámetros posicionales<br />

  utter_getopts_codigo:      
  - text: "code:bash:bash/getopts.sh"

      
  utter_temario:
  - text: >
      Estos son los temas con los que te puedo ayudar:<br />
       - Bloques<br />
       - Códigos de retorno (verdad y falsedad)<br />
       - Comentario especial hash bang<br />
       - Ciclo for<br />
       - Ciclo while<br />
       - Comandos de testing<br />
       - Encadenamiento<br />
       - Expansión de sustitución de comando<br />
       - Expansión de variables<br />
       - Funciones<br />
       - Funciones recursivas<br />
       - Getopts<br />
       - Globbing<br />
       - If de bloque<br />
       - If de línea<br />
       - Parámetros<br />
       - Parámetros especiales<br />
       - Quoting<br />
       - Recorrer directorios<br />
       - Redirección de flujo<br />
       - Variables<br />
       
       

session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true
